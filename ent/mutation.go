// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/s14t284/simplebank/ent/account"
	"github.com/s14t284/simplebank/ent/entry"
	"github.com/s14t284/simplebank/ent/predicate"
	"github.com/s14t284/simplebank/ent/transfer"
	"github.com/s14t284/simplebank/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount  = "Account"
	TypeEntry    = "Entry"
	TypeTransfer = "Transfer"
	TypeUser     = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	balance               *int
	addbalance            *int
	currency              *string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	entries               map[int]struct{}
	removedentries        map[int]struct{}
	clearedentries        bool
	from_transfers        map[int]struct{}
	removedfrom_transfers map[int]struct{}
	clearedfrom_transfers bool
	to_transfers          map[int]struct{}
	removedto_transfers   map[int]struct{}
	clearedto_transfers   bool
	users                 *string
	clearedusers          bool
	done                  bool
	oldValue              func(context.Context) (*Account, error)
	predicates            []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwner sets the "owner" field.
func (m *AccountMutation) SetOwner(s string) {
	m.users = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *AccountMutation) Owner() (r string, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *AccountMutation) ResetOwner() {
	m.users = nil
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(i int) {
	m.balance = &i
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r int, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds i to the "balance" field.
func (m *AccountMutation) AddBalance(i int) {
	if m.addbalance != nil {
		*m.addbalance += i
	} else {
		m.addbalance = &i
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r int, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCurrency sets the "currency" field.
func (m *AccountMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *AccountMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *AccountMutation) ResetCurrency() {
	m.currency = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddEntryIDs adds the "entries" edge to the Entry entity by ids.
func (m *AccountMutation) AddEntryIDs(ids ...int) {
	if m.entries == nil {
		m.entries = make(map[int]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the Entry entity.
func (m *AccountMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the Entry entity was cleared.
func (m *AccountMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the Entry entity by IDs.
func (m *AccountMutation) RemoveEntryIDs(ids ...int) {
	if m.removedentries == nil {
		m.removedentries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entries, ids[i])
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the Entry entity.
func (m *AccountMutation) RemovedEntriesIDs() (ids []int) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *AccountMutation) EntriesIDs() (ids []int) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *AccountMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddFromTransferIDs adds the "from_transfers" edge to the Transfer entity by ids.
func (m *AccountMutation) AddFromTransferIDs(ids ...int) {
	if m.from_transfers == nil {
		m.from_transfers = make(map[int]struct{})
	}
	for i := range ids {
		m.from_transfers[ids[i]] = struct{}{}
	}
}

// ClearFromTransfers clears the "from_transfers" edge to the Transfer entity.
func (m *AccountMutation) ClearFromTransfers() {
	m.clearedfrom_transfers = true
}

// FromTransfersCleared reports if the "from_transfers" edge to the Transfer entity was cleared.
func (m *AccountMutation) FromTransfersCleared() bool {
	return m.clearedfrom_transfers
}

// RemoveFromTransferIDs removes the "from_transfers" edge to the Transfer entity by IDs.
func (m *AccountMutation) RemoveFromTransferIDs(ids ...int) {
	if m.removedfrom_transfers == nil {
		m.removedfrom_transfers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.from_transfers, ids[i])
		m.removedfrom_transfers[ids[i]] = struct{}{}
	}
}

// RemovedFromTransfers returns the removed IDs of the "from_transfers" edge to the Transfer entity.
func (m *AccountMutation) RemovedFromTransfersIDs() (ids []int) {
	for id := range m.removedfrom_transfers {
		ids = append(ids, id)
	}
	return
}

// FromTransfersIDs returns the "from_transfers" edge IDs in the mutation.
func (m *AccountMutation) FromTransfersIDs() (ids []int) {
	for id := range m.from_transfers {
		ids = append(ids, id)
	}
	return
}

// ResetFromTransfers resets all changes to the "from_transfers" edge.
func (m *AccountMutation) ResetFromTransfers() {
	m.from_transfers = nil
	m.clearedfrom_transfers = false
	m.removedfrom_transfers = nil
}

// AddToTransferIDs adds the "to_transfers" edge to the Transfer entity by ids.
func (m *AccountMutation) AddToTransferIDs(ids ...int) {
	if m.to_transfers == nil {
		m.to_transfers = make(map[int]struct{})
	}
	for i := range ids {
		m.to_transfers[ids[i]] = struct{}{}
	}
}

// ClearToTransfers clears the "to_transfers" edge to the Transfer entity.
func (m *AccountMutation) ClearToTransfers() {
	m.clearedto_transfers = true
}

// ToTransfersCleared reports if the "to_transfers" edge to the Transfer entity was cleared.
func (m *AccountMutation) ToTransfersCleared() bool {
	return m.clearedto_transfers
}

// RemoveToTransferIDs removes the "to_transfers" edge to the Transfer entity by IDs.
func (m *AccountMutation) RemoveToTransferIDs(ids ...int) {
	if m.removedto_transfers == nil {
		m.removedto_transfers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_transfers, ids[i])
		m.removedto_transfers[ids[i]] = struct{}{}
	}
}

// RemovedToTransfers returns the removed IDs of the "to_transfers" edge to the Transfer entity.
func (m *AccountMutation) RemovedToTransfersIDs() (ids []int) {
	for id := range m.removedto_transfers {
		ids = append(ids, id)
	}
	return
}

// ToTransfersIDs returns the "to_transfers" edge IDs in the mutation.
func (m *AccountMutation) ToTransfersIDs() (ids []int) {
	for id := range m.to_transfers {
		ids = append(ids, id)
	}
	return
}

// ResetToTransfers resets all changes to the "to_transfers" edge.
func (m *AccountMutation) ResetToTransfers() {
	m.to_transfers = nil
	m.clearedto_transfers = false
	m.removedto_transfers = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *AccountMutation) SetUsersID(id string) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *AccountMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *AccountMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *AccountMutation) UsersID() (id string, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) UsersIDs() (ids []string) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AccountMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.users != nil {
		fields = append(fields, account.FieldOwner)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.currency != nil {
		fields = append(fields, account.FieldCurrency)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldOwner:
		return m.Owner()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldCurrency:
		return m.Currency()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldOwner:
		return m.OldOwner(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldCurrency:
		return m.OldCurrency(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, account.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldBalance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldOwner:
		m.ResetOwner()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldCurrency:
		m.ResetCurrency()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.entries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.from_transfers != nil {
		edges = append(edges, account.EdgeFromTransfers)
	}
	if m.to_transfers != nil {
		edges = append(edges, account.EdgeToTransfers)
	}
	if m.users != nil {
		edges = append(edges, account.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFromTransfers:
		ids := make([]ent.Value, 0, len(m.from_transfers))
		for id := range m.from_transfers {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeToTransfers:
		ids := make([]ent.Value, 0, len(m.to_transfers))
		for id := range m.to_transfers {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedentries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.removedfrom_transfers != nil {
		edges = append(edges, account.EdgeFromTransfers)
	}
	if m.removedto_transfers != nil {
		edges = append(edges, account.EdgeToTransfers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFromTransfers:
		ids := make([]ent.Value, 0, len(m.removedfrom_transfers))
		for id := range m.removedfrom_transfers {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeToTransfers:
		ids := make([]ent.Value, 0, len(m.removedto_transfers))
		for id := range m.removedto_transfers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedentries {
		edges = append(edges, account.EdgeEntries)
	}
	if m.clearedfrom_transfers {
		edges = append(edges, account.EdgeFromTransfers)
	}
	if m.clearedto_transfers {
		edges = append(edges, account.EdgeToTransfers)
	}
	if m.clearedusers {
		edges = append(edges, account.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeEntries:
		return m.clearedentries
	case account.EdgeFromTransfers:
		return m.clearedfrom_transfers
	case account.EdgeToTransfers:
		return m.clearedto_transfers
	case account.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeEntries:
		m.ResetEntries()
		return nil
	case account.EdgeFromTransfers:
		m.ResetFromTransfers()
		return nil
	case account.EdgeToTransfers:
		m.ResetToTransfers()
		return nil
	case account.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// EntryMutation represents an operation that mutates the Entry nodes in the graph.
type EntryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	amount          *int
	addamount       *int
	created_at      *time.Time
	clearedFields   map[string]struct{}
	accounts        *int
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*Entry, error)
	predicates      []predicate.Entry
}

var _ ent.Mutation = (*EntryMutation)(nil)

// entryOption allows management of the mutation configuration using functional options.
type entryOption func(*EntryMutation)

// newEntryMutation creates new mutation for the Entry entity.
func newEntryMutation(c config, op Op, opts ...entryOption) *EntryMutation {
	m := &EntryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryID sets the ID field of the mutation.
func withEntryID(id int) entryOption {
	return func(m *EntryMutation) {
		var (
			err   error
			once  sync.Once
			value *Entry
		)
		m.oldValue = func(ctx context.Context) (*Entry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntry sets the old Entry of the mutation.
func withEntry(node *Entry) entryOption {
	return func(m *EntryMutation) {
		m.oldValue = func(context.Context) (*Entry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *EntryMutation) SetAccountID(i int) {
	m.accounts = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *EntryMutation) AccountID() (r int, exists bool) {
	v := m.accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *EntryMutation) ResetAccountID() {
	m.accounts = nil
}

// SetAmount sets the "amount" field.
func (m *EntryMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *EntryMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *EntryMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *EntryMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *EntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountsID sets the "accounts" edge to the Account entity by id.
func (m *EntryMutation) SetAccountsID(id int) {
	m.accounts = &id
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *EntryMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *EntryMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// AccountsID returns the "accounts" edge ID in the mutation.
func (m *EntryMutation) AccountsID() (id int, exists bool) {
	if m.accounts != nil {
		return *m.accounts, true
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountsID instead. It exists only for internal usage by the builders.
func (m *EntryMutation) AccountsIDs() (ids []int) {
	if id := m.accounts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *EntryMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
}

// Where appends a list predicates to the EntryMutation builder.
func (m *EntryMutation) Where(ps ...predicate.Entry) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Entry).
func (m *EntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.accounts != nil {
		fields = append(fields, entry.FieldAccountID)
	}
	if m.amount != nil {
		fields = append(fields, entry.FieldAmount)
	}
	if m.created_at != nil {
		fields = append(fields, entry.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entry.FieldAccountID:
		return m.AccountID()
	case entry.FieldAmount:
		return m.Amount()
	case entry.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entry.FieldAccountID:
		return m.OldAccountID(ctx)
	case entry.FieldAmount:
		return m.OldAmount(ctx)
	case entry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Entry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entry.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case entry.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case entry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Entry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, entry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entry.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Entry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Entry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryMutation) ResetField(name string) error {
	switch name {
	case entry.FieldAccountID:
		m.ResetAccountID()
		return nil
	case entry.FieldAmount:
		m.ResetAmount()
		return nil
	case entry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Entry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, entry.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entry.EdgeAccounts:
		if id := m.accounts; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, entry.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryMutation) EdgeCleared(name string) bool {
	switch name {
	case entry.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryMutation) ClearEdge(name string) error {
	switch name {
	case entry.EdgeAccounts:
		m.ClearAccounts()
		return nil
	}
	return fmt.Errorf("unknown Entry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryMutation) ResetEdge(name string) error {
	switch name {
	case entry.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown Entry edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	amount               *int
	addamount            *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	from_accounts        *int
	clearedfrom_accounts bool
	to_accounts          *int
	clearedto_accounts   bool
	done                 bool
	oldValue             func(context.Context) (*Transfer, error)
	predicates           []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id int) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromAccountID sets the "from_account_id" field.
func (m *TransferMutation) SetFromAccountID(i int) {
	m.from_accounts = &i
}

// FromAccountID returns the value of the "from_account_id" field in the mutation.
func (m *TransferMutation) FromAccountID() (r int, exists bool) {
	v := m.from_accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAccountID returns the old "from_account_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldFromAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAccountID: %w", err)
	}
	return oldValue.FromAccountID, nil
}

// ResetFromAccountID resets all changes to the "from_account_id" field.
func (m *TransferMutation) ResetFromAccountID() {
	m.from_accounts = nil
}

// SetToAccountID sets the "to_account_id" field.
func (m *TransferMutation) SetToAccountID(i int) {
	m.to_accounts = &i
}

// ToAccountID returns the value of the "to_account_id" field in the mutation.
func (m *TransferMutation) ToAccountID() (r int, exists bool) {
	v := m.to_accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldToAccountID returns the old "to_account_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldToAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAccountID: %w", err)
	}
	return oldValue.ToAccountID, nil
}

// ResetToAccountID resets all changes to the "to_account_id" field.
func (m *TransferMutation) ResetToAccountID() {
	m.to_accounts = nil
}

// SetAmount sets the "amount" field.
func (m *TransferMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransferMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TransferMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransferMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransferMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransferMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransferMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransferMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFromAccountsID sets the "from_accounts" edge to the Account entity by id.
func (m *TransferMutation) SetFromAccountsID(id int) {
	m.from_accounts = &id
}

// ClearFromAccounts clears the "from_accounts" edge to the Account entity.
func (m *TransferMutation) ClearFromAccounts() {
	m.clearedfrom_accounts = true
}

// FromAccountsCleared reports if the "from_accounts" edge to the Account entity was cleared.
func (m *TransferMutation) FromAccountsCleared() bool {
	return m.clearedfrom_accounts
}

// FromAccountsID returns the "from_accounts" edge ID in the mutation.
func (m *TransferMutation) FromAccountsID() (id int, exists bool) {
	if m.from_accounts != nil {
		return *m.from_accounts, true
	}
	return
}

// FromAccountsIDs returns the "from_accounts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromAccountsID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) FromAccountsIDs() (ids []int) {
	if id := m.from_accounts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromAccounts resets all changes to the "from_accounts" edge.
func (m *TransferMutation) ResetFromAccounts() {
	m.from_accounts = nil
	m.clearedfrom_accounts = false
}

// SetToAccountsID sets the "to_accounts" edge to the Account entity by id.
func (m *TransferMutation) SetToAccountsID(id int) {
	m.to_accounts = &id
}

// ClearToAccounts clears the "to_accounts" edge to the Account entity.
func (m *TransferMutation) ClearToAccounts() {
	m.clearedto_accounts = true
}

// ToAccountsCleared reports if the "to_accounts" edge to the Account entity was cleared.
func (m *TransferMutation) ToAccountsCleared() bool {
	return m.clearedto_accounts
}

// ToAccountsID returns the "to_accounts" edge ID in the mutation.
func (m *TransferMutation) ToAccountsID() (id int, exists bool) {
	if m.to_accounts != nil {
		return *m.to_accounts, true
	}
	return
}

// ToAccountsIDs returns the "to_accounts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToAccountsID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) ToAccountsIDs() (ids []int) {
	if id := m.to_accounts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToAccounts resets all changes to the "to_accounts" edge.
func (m *TransferMutation) ResetToAccounts() {
	m.to_accounts = nil
	m.clearedto_accounts = false
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.from_accounts != nil {
		fields = append(fields, transfer.FieldFromAccountID)
	}
	if m.to_accounts != nil {
		fields = append(fields, transfer.FieldToAccountID)
	}
	if m.amount != nil {
		fields = append(fields, transfer.FieldAmount)
	}
	if m.created_at != nil {
		fields = append(fields, transfer.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldFromAccountID:
		return m.FromAccountID()
	case transfer.FieldToAccountID:
		return m.ToAccountID()
	case transfer.FieldAmount:
		return m.Amount()
	case transfer.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldFromAccountID:
		return m.OldFromAccountID(ctx)
	case transfer.FieldToAccountID:
		return m.OldToAccountID(ctx)
	case transfer.FieldAmount:
		return m.OldAmount(ctx)
	case transfer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldFromAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAccountID(v)
		return nil
	case transfer.FieldToAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAccountID(v)
		return nil
	case transfer.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transfer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transfer.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldFromAccountID:
		m.ResetFromAccountID()
		return nil
	case transfer.FieldToAccountID:
		m.ResetToAccountID()
		return nil
	case transfer.FieldAmount:
		m.ResetAmount()
		return nil
	case transfer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_accounts != nil {
		edges = append(edges, transfer.EdgeFromAccounts)
	}
	if m.to_accounts != nil {
		edges = append(edges, transfer.EdgeToAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeFromAccounts:
		if id := m.from_accounts; id != nil {
			return []ent.Value{*id}
		}
	case transfer.EdgeToAccounts:
		if id := m.to_accounts; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_accounts {
		edges = append(edges, transfer.EdgeFromAccounts)
	}
	if m.clearedto_accounts {
		edges = append(edges, transfer.EdgeToAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	switch name {
	case transfer.EdgeFromAccounts:
		return m.clearedfrom_accounts
	case transfer.EdgeToAccounts:
		return m.clearedto_accounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	switch name {
	case transfer.EdgeFromAccounts:
		m.ClearFromAccounts()
		return nil
	case transfer.EdgeToAccounts:
		m.ClearToAccounts()
		return nil
	}
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	switch name {
	case transfer.EdgeFromAccounts:
		m.ResetFromAccounts()
		return nil
	case transfer.EdgeToAccounts:
		m.ResetToAccounts()
		return nil
	}
	return fmt.Errorf("unknown Transfer edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	hashed_password     *string
	full_name           *string
	email               *string
	password_changed_at *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	accounts            map[int]struct{}
	removedaccounts     map[int]struct{}
	clearedaccounts     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHashedPassword sets the "hashed_password" field.
func (m *UserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *UserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *UserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordChangedAt sets the "password_changed_at" field.
func (m *UserMutation) SetPasswordChangedAt(t time.Time) {
	m.password_changed_at = &t
}

// PasswordChangedAt returns the value of the "password_changed_at" field in the mutation.
func (m *UserMutation) PasswordChangedAt() (r time.Time, exists bool) {
	v := m.password_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordChangedAt returns the old "password_changed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordChangedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordChangedAt: %w", err)
	}
	return oldValue.PasswordChangedAt, nil
}

// ResetPasswordChangedAt resets all changes to the "password_changed_at" field.
func (m *UserMutation) ResetPasswordChangedAt() {
	m.password_changed_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *UserMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *UserMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *UserMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *UserMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *UserMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *UserMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *UserMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.hashed_password != nil {
		fields = append(fields, user.FieldHashedPassword)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_changed_at != nil {
		fields = append(fields, user.FieldPasswordChangedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldHashedPassword:
		return m.HashedPassword()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordChangedAt:
		return m.PasswordChangedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordChangedAt:
		return m.OldPasswordChangedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordChangedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordChangedAt:
		m.ResetPasswordChangedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedaccounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, user.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
